<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live GD AI Agent</title>

    <!-- Google Analytics 4 -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-27RRM0RXZ5"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-27RRM0RXZ5');
    </script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }

        /* Full-screen background */
        .gd-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('background.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 0;
        }

        /* AI Participant Hotspots */
        .ai-hotspot {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: default;
            z-index: 10;
            transition: all 0.3s ease;
        }

        /* Glow effect for active speaker */
        .ai-hotspot.speaking {
            box-shadow:
                0 0 20px rgba(108, 92, 231, 0.8),
                0 0 40px rgba(108, 92, 231, 0.6),
                0 0 60px rgba(108, 92, 231, 0.4);
            animation: speakerPulse 2s ease-in-out infinite;
        }

        @keyframes speakerPulse {

            0%,
            100% {
                box-shadow:
                    0 0 20px rgba(108, 92, 231, 0.8),
                    0 0 40px rgba(108, 92, 231, 0.6),
                    0 0 60px rgba(108, 92, 231, 0.4);
            }

            50% {
                box-shadow:
                    0 0 30px rgba(108, 92, 231, 1),
                    0 0 60px rgba(108, 92, 231, 0.8),
                    0 0 90px rgba(108, 92, 231, 0.6);
            }
        }

        /* Position hotspots - Sneha (leftmost), Parth (2nd), Harsh (3rd), Anshika (rightmost) */
        #ai1-hotspot {
            /* Parth - 2nd person from left (gray suit male) */
            top: 10%;
            left: 31.30%;
            width: 160px;
            height: 180px;
            border-radius: 45%;
        }

        #ai2-hotspot {
            /* Sneha - leftmost (female in dark suit) */
            top: 15.8%;
            left: 8.7%;
            width: 165px;
            height: 180px;
            border-radius: 45%;
        }

        #ai3-hotspot {
            /* Harsh - 3rd person (light blue shirt male) */
            top: 9%;
            right: 30.5%;
            width: 160px;
            height: 180px;
            border-radius: 45%;
        }

        #ai4-hotspot {
            /* Anshika - rightmost (female in dark suit) */
            top: 16%;
            right: 9%;
            width: 160px;
            height: 180px;
            border-radius: 45%;
        }

        /* Status indicator at top */
        .status-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 30px;
            border-radius: 30px;
            font-size: 16px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        /* GD Session Timer */
        .gd-timer {
            position: fixed;
            top: 20px;
            right: 30px;
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
            z-index: 100;
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(108, 92, 231, 0.3);
        }

        .gd-timer.active {
            display: flex;
        }

        .gd-timer-icon {
            font-size: 16px;
        }

        .gd-timer-value {
            font-family: 'Segoe UI', monospace;
            font-weight: 600;
            color: #a29bfe;
            letter-spacing: 1px;
        }

        .status-bar.speaking {
            border: 1px solid rgba(108, 92, 231, 0.5);
        }

        .status-bar.user-turn {
            border: 1px solid rgba(46, 204, 113, 0.5);
            color: #2ecc71;
        }

        /* User Turn Modal */
        .user-modal-overlay {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 30px;
            justify-content: center;
            z-index: 200;
        }

        .user-modal-overlay.active {
            display: flex;
        }

        .user-modal {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(108, 92, 231, 0.5);
            border-radius: 20px;
            padding: 25px 50px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
        }

        .user-modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }

        .user-modal-countdown {
            font-size: 48px;
            font-weight: bold;
            color: #6c5ce7;
            margin-bottom: 20px;
        }

        .user-modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .speak-btn {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            font-size: 18px;
            font-weight: 600;
            padding: 15px 40px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            animation: speakBtnPulse 1.5s infinite;
        }

        @keyframes speakBtnPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(108, 92, 231, 0.4);
            }

            50% {
                box-shadow: 0 0 30px rgba(108, 92, 231, 0.8);
            }
        }

        .speak-btn:hover {
            transform: scale(1.05);
        }

        .skip-btn {
            background: transparent;
            color: #888;
            font-size: 14px;
            padding: 10px 25px;
            border: 1px solid #555;
            border-radius: 20px;
            cursor: pointer;
        }

        .skip-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .space-hint {
            font-size: 11px;
            color: #666;
            margin-top: 15px;
        }

        /* Hidden start button */
        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        .start-overlay.hidden {
            display: none;
        }

        .start-btn {
            background: linear-gradient(135deg, #00b894, #55efc4);
            color: #000;
            font-size: 18px;
            font-weight: bold;
            padding: 15px 50px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .start-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 184, 148, 0.5);
        }

        .start-btn:disabled {
            background: linear-gradient(135deg, #636e72, #95a5a6);
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Start screen container */
        .start-container {
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(108, 92, 231, 0.3);
            border-radius: 24px;
            padding: 35px 45px;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
        }

        .start-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 25px;
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .input-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #dfe6e9;
            margin-bottom: 8px;
        }

        .optional-hint {
            font-weight: 400;
            color: #636e72;
            font-size: 12px;
        }

        .text-input {
            width: 100%;
            padding: 14px 18px;
            font-size: 15px;
            border: 2px solid rgba(108, 92, 231, 0.3);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            outline: none;
            transition: all 0.3s;
            box-sizing: border-box;
        }

        .text-input:focus {
            border-color: #6c5ce7;
            box-shadow: 0 0 15px rgba(108, 92, 231, 0.3);
        }

        .text-input::placeholder {
            color: #636e72;
        }

        /* Genre grid */
        .genre-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 8px;
        }

        .genre-card {
            background: rgba(45, 52, 70, 0.6);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .genre-card:hover {
            background: rgba(108, 92, 231, 0.2);
            border-color: rgba(108, 92, 231, 0.5);
            transform: translateY(-2px);
        }

        .genre-card.selected {
            background: rgba(108, 92, 231, 0.3);
            border-color: #6c5ce7;
            box-shadow: 0 0 15px rgba(108, 92, 231, 0.4);
        }

        .genre-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }

        .genre-name {
            font-size: 11px;
            color: #dfe6e9;
            line-height: 1.3;
        }

        /* Validation hint */
        .validation-hint {
            font-size: 13px;
            color: #636e72;
            margin: 15px 0;
            min-height: 20px;
        }

        .validation-hint.valid {
            color: #00b894;
        }

        .validation-hint.error {
            color: #e17055;
        }

        /* Thinking Timer Overlay */
        .thinking-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 600;
        }

        .thinking-overlay.hidden {
            display: none;
        }

        .thinking-content {
            text-align: center;
            max-width: 700px;
            padding: 40px;
        }

        .thinking-instruction {
            font-size: 18px;
            color: #a29bfe;
            margin-bottom: 20px;
            letter-spacing: 1px;
        }

        .thinking-topic {
            font-size: 26px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 40px;
            line-height: 1.4;
            padding: 0 20px;
        }

        .thinking-timer {
            font-size: 80px;
            font-weight: 700;
            color: #6c5ce7;
            margin-bottom: 15px;
            font-family: 'Segoe UI', monospace;
        }

        .thinking-label {
            font-size: 14px;
            color: #636e72;
            margin-bottom: 40px;
        }

        .skip-timer-btn {
            background: transparent;
            border: 2px solid #636e72;
            color: #636e72;
            padding: 12px 35px;
            border-radius: 30px;
            font-size: 14px;
            cursor: not-allowed;
            transition: all 0.3s;
            opacity: 0.5;
        }

        .skip-timer-btn.enabled {
            border-color: #6c5ce7;
            color: #6c5ce7;
            cursor: pointer;
            opacity: 1;
        }

        .skip-timer-btn.enabled:hover {
            background: rgba(108, 92, 231, 0.2);
            transform: scale(1.05);
        }

        .skip-hint {
            font-size: 11px;
            color: #4a5568;
            margin-top: 15px;
        }

        /* Recording indicator */
        .recording-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(231, 76, 60, 0.9);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 14px;
            display: none;
            z-index: 150;
            text-align: center;
        }

        .recording-indicator.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            animation: recordPulse 1s infinite;
        }

        .recording-text {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stop-btn {
            background: #c0392b;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stop-btn:hover {
            background: #a93226;
            transform: scale(1.05);
        }

        .space-stop-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }

        @keyframes recordPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.85;
            }
        }

        /* Cooldown indicator */
        .cooldown-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(52, 73, 94, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 14px;
            display: none;
            z-index: 140;
            color: #bdc3c7;
        }

        .cooldown-indicator.active {
            display: block;
        }

        .cooldown-time {
            color: #f39c12;
            font-weight: bold;
        }

        /* ========== POST-GD ANALYTICS OVERLAY ========== */
        .analytics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a14 0%, #1a1a2e 100%);
            z-index: 700;
            overflow-y: auto;
            display: none;
        }

        .analytics-overlay.active {
            display: block;
        }

        .analytics-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 30px 60px;
        }

        .analytics-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 1px solid rgba(108, 92, 231, 0.3);
        }

        .analytics-title {
            font-size: 28px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }

        .analytics-subtitle {
            font-size: 14px;
            color: #a29bfe;
        }

        .analytics-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 28px;
            margin-bottom: 24px;
        }

        .analytics-section-title {
            font-size: 16px;
            font-weight: 600;
            color: #a29bfe;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 18px;
        }

        .analytics-section-content {
            font-size: 15px;
            line-height: 1.7;
            color: #e0e0e0;
        }

        .analytics-section-content p {
            margin-bottom: 12px;
        }

        .analytics-section-content p:last-child {
            margin-bottom: 0;
        }

        /* Session overview compact stats */
        .session-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .stat-item {
            background: rgba(108, 92, 231, 0.1);
            padding: 16px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #6c5ce7;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #a29bfe;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Theme tags */
        .theme-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .theme-tag {
            background: rgba(108, 92, 231, 0.15);
            border: 1px solid rgba(108, 92, 231, 0.3);
            padding: 10px 18px;
            border-radius: 25px;
            font-size: 14px;
            color: #d4cfff;
        }

        /* User contributions */
        .contribution-item {
            background: rgba(255, 255, 255, 0.02);
            border-left: 3px solid #6c5ce7;
            padding: 16px 20px;
            margin-bottom: 16px;
            border-radius: 0 10px 10px 0;
        }

        .contribution-item:last-child {
            margin-bottom: 0;
        }

        .contribution-turn {
            font-size: 11px;
            color: #a29bfe;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .contribution-text {
            font-size: 14px;
            line-height: 1.6;
            color: #e0e0e0;
        }

        /* Feedback sections */
        .feedback-category {
            margin-bottom: 24px;
        }

        .feedback-category:last-child {
            margin-bottom: 0;
        }

        .feedback-category-title {
            font-size: 14px;
            font-weight: 600;
            color: #74b9ff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .feedback-category-title.strengths {
            color: #55efc4;
        }

        .feedback-category-title.improvements {
            color: #ffeaa7;
        }

        .feedback-points {
            padding-left: 20px;
        }

        .feedback-point {
            margin-bottom: 10px;
            color: #d0d0d0;
            font-size: 14px;
            line-height: 1.6;
        }

        /* Flow assessment */
        .flow-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        .flow-metric {
            text-align: center;
            padding: 20px 16px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
        }

        .flow-metric-label {
            font-size: 11px;
            color: #a29bfe;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .flow-metric-value {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }

        /* Action buttons */
        .analytics-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .analytics-btn {
            padding: 14px 35px;
            border-radius: 30px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        .analytics-btn-primary {
            background: #6c5ce7;
            color: #fff;
            border: none;
        }

        .analytics-btn-primary:hover {
            background: #5a4bd1;
            transform: translateY(-2px);
        }

        .analytics-btn-secondary {
            background: transparent;
            color: #a29bfe;
            border: 1px solid #a29bfe;
        }

        .analytics-btn-secondary:hover {
            background: rgba(108, 92, 231, 0.1);
        }

        /* Loading state */
        .analytics-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 400px;
        }

        .analytics-loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(108, 92, 231, 0.3);
            border-top-color: #6c5ce7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .analytics-loading-text {
            font-size: 16px;
            color: #a29bfe;
        }

        /* ========== MOBILE ROTATE DEVICE OVERLAY ========== */
        .rotate-device-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a14 0%, #1a1a2e 100%);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 30px;
        }

        .rotate-device-icon {
            font-size: 80px;
            margin-bottom: 30px;
            animation: rotatePhone 2s ease-in-out infinite;
        }

        @keyframes rotatePhone {

            0%,
            100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-15deg);
            }

            75% {
                transform: rotate(90deg);
            }
        }

        .rotate-device-title {
            font-size: 24px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
        }

        .rotate-device-text {
            font-size: 16px;
            color: #a29bfe;
            max-width: 300px;
            line-height: 1.6;
        }

        /* ========== MOBILE LANDSCAPE MODE STYLES ========== */
        @media screen and (max-width: 932px) and (orientation: portrait) {

            /* Show rotate overlay in portrait mode on mobile */
            .rotate-device-overlay {
                display: flex !important;
            }
        }

        @media screen and (max-width: 932px) and (orientation: landscape) {

            /* Hide rotate overlay in landscape */
            .rotate-device-overlay {
                display: none !important;
            }

            /* Make start container scrollable and fit the screen */
            .start-container {
                max-width: 95%;
                max-height: 95vh;
                padding: 20px 25px;
                overflow-y: auto;
            }

            .start-title {
                font-size: 22px;
                margin-bottom: 15px;
            }

            .input-group {
                margin-bottom: 12px;
            }

            .input-group label {
                font-size: 12px;
                margin-bottom: 5px;
            }

            .text-input {
                padding: 10px 14px;
                font-size: 14px;
            }

            /* Responsive genre grid for mobile landscape */
            .genre-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 6px;
            }

            .genre-card {
                padding: 8px 4px;
                border-radius: 8px;
            }

            .genre-icon {
                font-size: 18px;
                margin-bottom: 3px;
            }

            .genre-name {
                font-size: 9px;
            }

            .validation-hint {
                font-size: 11px;
                margin: 10px 0;
            }

            .start-btn {
                padding: 10px 30px;
                font-size: 14px;
            }

            /* AI hotspots responsive positioning for mobile landscape */
            #ai1-hotspot {
                /* Parth - 2nd person from left */
                top: 4%;
                left: 31.5%;
                width: 12vw;
                height: 30vh;
            }

            #ai2-hotspot {
                /* Sneha - leftmost */
                top: 13%;
                left: 8.5%;
                width: 12vw;
                height: 30vh;
            }

            #ai3-hotspot {
                /* Harsh - 3rd person */
                top: 5.2%;
                right: 31%;
                left: auto;
                width: 12vw;
                height: 30vh;
            }

            #ai4-hotspot {
                /* Anshika - rightmost */
                top: 12%;
                right: 9.5%;
                left: auto;
                width: 12vw;
                height: 30vh;
            }

            /* Status bar */
            .status-bar {
                padding: 8px 20px;
                font-size: 13px;
                top: 10px;
            }

            /* GD Timer */
            .gd-timer {
                padding: 6px 14px;
                font-size: 14px;
                top: 10px;
                right: 15px;
            }

            /* User modal */
            .user-modal {
                padding: 15px 30px;
            }

            .user-modal-title {
                font-size: 16px;
            }

            .user-modal-countdown {
                font-size: 36px;
            }

            .speak-btn {
                padding: 10px 25px;
                font-size: 14px;
            }

            .skip-btn {
                padding: 6px 15px;
                font-size: 12px;
            }

            /* Thinking overlay */
            .thinking-content {
                padding: 20px;
            }

            .thinking-instruction {
                font-size: 14px;
            }

            .thinking-topic {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .thinking-timer {
                font-size: 50px;
            }

            /* Recording indicator */
            .recording-indicator {
                padding: 10px 20px;
                font-size: 12px;
            }

            /* Analytics overlay */
            .analytics-container {
                padding: 20px 15px 40px;
            }

            .analytics-section {
                padding: 18px;
                margin-bottom: 16px;
            }

            .analytics-title {
                font-size: 22px;
            }

            .session-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .stat-item {
                padding: 12px;
            }

            .stat-value {
                font-size: 18px;
            }

            .flow-metrics {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }

            .flow-metric {
                padding: 12px 8px;
            }
        }

        /* Extra small mobile landscape (iPhone SE, etc.) */
        @media screen and (max-width: 700px) and (orientation: landscape) {
            .start-container {
                padding: 15px 20px;
            }

            .start-title {
                font-size: 18px;
                margin-bottom: 12px;
            }

            .genre-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 4px;
            }

            .genre-card {
                padding: 6px 3px;
            }

            .genre-icon {
                font-size: 16px;
                margin-bottom: 2px;
            }

            .genre-name {
                font-size: 8px;
            }

            .text-input {
                padding: 8px 12px;
                font-size: 13px;
            }

            .start-btn {
                padding: 8px 25px;
                font-size: 12px;
            }

            /* AI hotspots for extra small mobile landscape */
            #ai1-hotspot {
                top: 6%;
                left: 26%;
                width: 15vw;
                height: 30vh;
            }

            #ai2-hotspot {
                top: 12%;
                left: 3%;
                width: 15vw;
                height: 30vh;
            }

            #ai3-hotspot {
                top: 5%;
                right: 25%;
                left: auto;
                width: 15vw;
                height: 30vh;
            }

            #ai4-hotspot {
                top: 12%;
                right: 4%;
                left: auto;
                width: 15vw;
                height: 30vh;
            }
        }
    </style>
</head>

<body>
    <!-- Rotate Device Overlay (shown on mobile portrait) -->
    <div class="rotate-device-overlay" id="rotateOverlay">
        <div class="rotate-device-icon">üì±</div>
        <div class="rotate-device-title">Please Rotate Your Device</div>
        <div class="rotate-device-text">This immersive GD experience is best viewed in landscape mode. Please rotate
            your device horizontally.</div>
    </div>

    <!-- Full-screen GD Background -->
    <div class="gd-background"></div>

    <!-- AI Participant Hotspots (invisible, positioned over faces) -->
    <div class="ai-hotspot" id="ai1-hotspot"></div>
    <div class="ai-hotspot" id="ai2-hotspot"></div>
    <div class="ai-hotspot" id="ai3-hotspot"></div>
    <div class="ai-hotspot" id="ai4-hotspot"></div>

    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">Click to begin</div>

    <!-- GD Session Timer -->
    <div class="gd-timer" id="gdTimer">
        <span class="gd-timer-icon">‚è±Ô∏è</span>
        <span class="gd-timer-value" id="gdTimerValue">00:00</span>
    </div>

    <!-- Start Overlay -->
    <div class="start-overlay" id="startOverlay">
        <div class="start-container">
            <h1 class="start-title">üéØ Setup Your GD Session</h1>

            <!-- User Name (mandatory) -->
            <div class="input-group">
                <label>Your Name *</label>
                <input type="text" id="userName" class="text-input" placeholder="Enter your name" />
            </div>

            <!-- Genre Selection -->
            <div class="input-group">
                <label>Select Genre <span class="optional-hint">(used if no topic provided)</span></label>
                <div class="genre-grid" id="genreGrid">
                    <div class="genre-card" data-genre="politics">
                        <div class="genre-icon">üèõÔ∏è</div>
                        <div class="genre-name">Politics & Governance</div>
                    </div>
                    <div class="genre-card" data-genre="business">
                        <div class="genre-icon">üíº</div>
                        <div class="genre-name">Business & Economy</div>
                    </div>
                    <div class="genre-card" data-genre="education">
                        <div class="genre-icon">üéì</div>
                        <div class="genre-name">Education & Careers</div>
                    </div>
                    <div class="genre-card" data-genre="environment">
                        <div class="genre-icon">üåç</div>
                        <div class="genre-name">Environment & Climate</div>
                    </div>
                    <div class="genre-card" data-genre="technology">
                        <div class="genre-icon">ü§ñ</div>
                        <div class="genre-name">Technology & AI</div>
                    </div>
                    <div class="genre-card" data-genre="healthcare">
                        <div class="genre-icon">üè•</div>
                        <div class="genre-name">Healthcare & Wellness</div>
                    </div>
                    <div class="genre-card" data-genre="society">
                        <div class="genre-icon">üé≠</div>
                        <div class="genre-name">Society & Culture</div>
                    </div>
                    <div class="genre-card" data-genre="ethics">
                        <div class="genre-icon">‚öñÔ∏è</div>
                        <div class="genre-name">Ethics & Philosophy</div>
                    </div>
                    <div class="genre-card" data-genre="innovation">
                        <div class="genre-icon">üöÄ</div>
                        <div class="genre-name">Innovation & Startups</div>
                    </div>
                    <div class="genre-card" data-genre="global">
                        <div class="genre-icon">üåê</div>
                        <div class="genre-name">Global Affairs</div>
                    </div>
                </div>
            </div>

            <!-- Topic Input -->
            <div class="input-group">
                <label>GD Topic <span class="optional-hint">(optional ‚Äî overrides genre)</span></label>
                <input type="text" id="topicInput" class="text-input"
                    placeholder="Enter GD topic (optional ‚Äî overrides genre-based generation)" />
            </div>

            <div class="validation-hint" id="validationHint">Please enter your name</div>
            <button class="start-btn" id="startBtn" disabled>üé¨ Start GD Session</button>
        </div>
    </div>

    <!-- User Turn Modal -->
    <div class="user-modal-overlay" id="userModal">
        <div class="user-modal">
            <div class="user-modal-title">üé§ Your Turn</div>
            <div class="user-modal-countdown" id="modalCountdown">4</div>
            <div class="user-modal-buttons">
                <button class="speak-btn" id="speakBtn">üé§ Speak</button>
                <button class="skip-btn" id="skipBtn">Skip</button>
            </div>
            <div class="space-hint">Press SPACE to speak</div>
        </div>
    </div>

    <!-- Recording Indicator -->
    <div class="recording-indicator" id="recordingIndicator">
        <div class="recording-text">üî¥ Recording...</div>
        <button class="stop-btn" id="stopRecordingBtn">‚èπ Stop</button>
        <div class="space-stop-hint">Press SPACE to stop</div>
    </div>

    <!-- Cooldown Indicator -->
    <div class="cooldown-indicator" id="cooldownIndicator">
        ‚è≥ Next turn in <span class="cooldown-time" id="cooldownTime">45</span>s
    </div>

    <!-- Thinking Timer Overlay -->
    <div class="thinking-overlay hidden" id="thinkingOverlay">
        <div class="thinking-content">
            <div class="thinking-instruction">üìñ 1 MINUTE TO THINK BEFORE THE DISCUSSION BEGINS</div>
            <div class="thinking-topic" id="thinkingTopic">"Your topic will appear here"</div>
            <div class="thinking-timer" id="thinkingTimer">60</div>
            <div class="thinking-label">seconds remaining</div>
            <button class="skip-timer-btn" id="skipTimerBtn" disabled>‚è≠Ô∏è Skip Timer</button>
            <div class="skip-hint" id="skipHint">Available in 30 seconds...</div>
        </div>
    </div>

    <!-- Post-GD Analytics Overlay -->
    <div class="analytics-overlay" id="analyticsOverlay">
        <div class="analytics-container" id="analyticsContent">
            <!-- Loading state (initially shown) -->
            <div class="analytics-loading" id="analyticsLoading">
                <div class="analytics-loading-spinner"></div>
                <div class="analytics-loading-text">Analyzing your discussion...</div>
            </div>
        </div>
    </div>

    <script>
        // ========== API CONFIGURATION (for cloud deployment) ==========
        // For cloud deployment, set window.API_BASE_URL before this script loads
        const API_BASE = window.API_BASE_URL || '';
        // Auto-detect WebSocket protocol based on page protocol (wss for https, ws for http)
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const WS_BASE = window.WS_BASE_URL || (window.API_BASE_URL ? window.API_BASE_URL.replace('https://', 'wss://').replace('http://', 'ws://') : `${wsProtocol}//${window.location.host}`);

        // ========== ORCHESTRATOR STATE ==========
        const orchestratorState = {
            lastSpeaker: null,
            turnCount: { AI_1: 0, AI_2: 0, AI_3: 0, AI_4: 0, User: 0 },
            maxTurns: { AI_1: 3, AI_2: 3, AI_3: 3, AI_4: 3, User: 3 },
            userCooldownUntil: null
        };

        // ========== SESSION STATE ==========
        let conversationMemory = [];
        let isSessionActive = false;
        let isRecording = false;
        let cooldownInterval = null;
        let globalTurnNumber = 0; // Track turn number for logging

        // ========== USER SPEAKING WINDOW STATE ==========
        let userWindowOpen = false;
        let userWindowTimer = null;
        let userStartedSpeaking = false;
        let windowCountdown = 0;
        let windowCountdownInterval = null;

        // ========== SPECULATIVE CACHE ==========
        let speculativeCache = {
            speaker: null,
            text: null,
            ready: false,
            promise: null,
            startTime: null,
            llmTime: null
        };

        // Audio/WebSocket
        let websocket = null;
        let mediaStream = null;
        let audioContext = null;
        let audioProcessor = null;
        let currentTranscript = '';
        let currentAudio = null;

        // DOM Elements
        const startOverlay = document.getElementById('startOverlay');
        const startBtn = document.getElementById('startBtn');
        const statusBar = document.getElementById('statusBar');
        const userModal = document.getElementById('userModal');
        const modalCountdown = document.getElementById('modalCountdown');
        const speakBtn = document.getElementById('speakBtn');
        const skipBtn = document.getElementById('skipBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const stopRecordingBtn = document.getElementById('stopRecordingBtn');
        const cooldownIndicator = document.getElementById('cooldownIndicator');
        const cooldownTimeEl = document.getElementById('cooldownTime');

        // Thinking timer elements
        const thinkingOverlay = document.getElementById('thinkingOverlay');
        const thinkingTopic = document.getElementById('thinkingTopic');
        const thinkingTimer = document.getElementById('thinkingTimer');
        const skipTimerBtn = document.getElementById('skipTimerBtn');
        const skipHint = document.getElementById('skipHint');

        // Thinking timer state
        let thinkingInterval = null;

        // Start form elements
        const userNameInput = document.getElementById('userName');
        const topicInput = document.getElementById('topicInput');
        const genreGrid = document.getElementById('genreGrid');
        const validationHint = document.getElementById('validationHint');
        const genreCards = document.querySelectorAll('.genre-card');

        // Form state
        let selectedGenre = null;
        let currentUserName = '';
        let currentTopic = '';

        // GD Timer elements
        const gdTimer = document.getElementById('gdTimer');
        const gdTimerValue = document.getElementById('gdTimerValue');
        let gdTimerInterval = null;
        let gdStartTime = null;

        // AI Hotspots
        const hotspots = {
            'AI_1': document.getElementById('ai1-hotspot'),
            'AI_2': document.getElementById('ai2-hotspot'),
            'AI_3': document.getElementById('ai3-hotspot'),
            'AI_4': document.getElementById('ai4-hotspot')
        };

        // ========== START FORM VALIDATION ==========
        function validateStartForm() {
            const userName = userNameInput.value.trim();
            const topic = topicInput.value.trim();
            const hasGenre = selectedGenre !== null;

            currentUserName = userName;
            currentTopic = topic;

            // Rule: Name required AND (topic OR genre)
            const isValid = userName.length > 0 && (topic.length > 0 || hasGenre);

            startBtn.disabled = !isValid;

            // Update hint text and styling
            validationHint.classList.remove('valid', 'error');

            if (!userName) {
                validationHint.textContent = 'Please enter your name';
                validationHint.classList.add('error');
            } else if (!topic && !hasGenre) {
                validationHint.textContent = 'Please enter a topic or select a genre';
                validationHint.classList.add('error');
            } else if (topic) {
                validationHint.textContent = '‚úì Using custom topic';
                validationHint.classList.add('valid');
            } else {
                validationHint.textContent = '‚úì Topic will be generated from selected genre';
                validationHint.classList.add('valid');
            }
        }

        // Genre card click handlers
        genreCards.forEach(card => {
            card.addEventListener('click', () => {
                // Deselect previous
                genreCards.forEach(c => c.classList.remove('selected'));
                // Select this one
                card.classList.add('selected');
                selectedGenre = card.dataset.genre;
                validateStartForm();
            });
        });

        // Input event listeners
        userNameInput.addEventListener('input', validateStartForm);
        topicInput.addEventListener('input', validateStartForm);

        // Participant Names
        const participantNames = {
            'AI_1': 'Parth',
            'AI_2': 'Sneha',
            'AI_3': 'Harsh',
            'AI_4': 'Anshika',
            'User': 'You'
        };

        // Get display name for a speaker
        function getDisplayName(speaker) {
            return participantNames[speaker] || speaker;
        }

        // ========== UI FUNCTIONS ==========
        function updateStatus(text, isUserTurn = false) {
            statusBar.textContent = text;
            statusBar.classList.toggle('user-turn', isUserTurn);
            statusBar.classList.toggle('speaking', !isUserTurn);
        }

        function setActiveSpeaker(speaker) {
            // Clear all glows
            Object.values(hotspots).forEach(h => h.classList.remove('speaking'));

            // Set glow on active speaker
            if (speaker && hotspots[speaker]) {
                hotspots[speaker].classList.add('speaking');
            }
        }

        // ========== ORCHESTRATOR LOGIC ==========
        function getEligibleSpeakers() {
            const eligible = [];
            const participants = ['AI_1', 'AI_2', 'AI_3', 'AI_4', 'User'];
            const now = Date.now();

            for (const p of participants) {
                if (p === orchestratorState.lastSpeaker) continue;
                if (orchestratorState.turnCount[p] >= orchestratorState.maxTurns[p]) continue;
                if (p === 'User' && orchestratorState.userCooldownUntil && now < orchestratorState.userCooldownUntil) continue;
                eligible.push(p);
            }

            return eligible;
        }

        function getNextSpeaker() {
            const eligible = getEligibleSpeakers();
            if (eligible.length === 0) return null;
            eligible.sort((a, b) => orchestratorState.turnCount[a] - orchestratorState.turnCount[b]);
            return eligible[0];
        }

        function getNextAISpeakerAfterUser() {
            const eligible = ['AI_1', 'AI_2', 'AI_3', 'AI_4'].filter(ai =>
                orchestratorState.turnCount[ai] < orchestratorState.maxTurns[ai]
            );
            if (eligible.length === 0) return null;
            eligible.sort((a, b) => orchestratorState.turnCount[a] - orchestratorState.turnCount[b]);
            return eligible[0];
        }

        function startUserCooldown() {
            const cooldownMs = (40 + Math.random() * 15) * 1000;
            orchestratorState.userCooldownUntil = Date.now() + cooldownMs;

            // Show cooldown indicator
            cooldownIndicator.classList.add('active');

            // Update countdown every second
            if (cooldownInterval) clearInterval(cooldownInterval);
            cooldownInterval = setInterval(() => {
                const remaining = Math.max(0, Math.ceil((orchestratorState.userCooldownUntil - Date.now()) / 1000));
                cooldownTimeEl.textContent = remaining;

                if (remaining <= 0) {
                    clearInterval(cooldownInterval);
                    cooldownInterval = null;
                    cooldownIndicator.classList.remove('active');
                }
            }, 1000);

            // Initial update
            cooldownTimeEl.textContent = Math.ceil(cooldownMs / 1000);
        }

        // ========== SPECULATIVE GENERATION ==========
        function triggerSpeculativeGeneration(speaker) {
            if (!speaker || speculativeCache.speaker === speaker) return;

            speculativeCache = {
                speaker: speaker,
                text: null,
                ready: false,
                promise: null,
                startTime: Date.now(),
                llmTime: null
            };

            console.log(`‚ö° [SPECULATIVE] Starting for ${speaker}`);

            speculativeCache.promise = fetch(`${API_BASE}/v4/ai-response`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    speaker: speaker,
                    memory: conversationMemory,
                    topic: window.currentGDTopic
                })
            })
                .then(res => res.json())
                .then(async data => {
                    speculativeCache.text = data.response;
                    speculativeCache.llmTime = ((Date.now() - speculativeCache.startTime) / 1000).toFixed(2);
                    console.log(`‚úÖ [SPECULATIVE] ${speaker} text ready in ${speculativeCache.llmTime}s, now synthesizing audio...`);

                    // Also pre-generate audio
                    try {
                        const ttsRes = await fetch(`${API_BASE}/synthesize`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text: data.response, speaker: speaker })
                        });

                        if (ttsRes.ok) {
                            const ttsData = await ttsRes.json();
                            if (ttsData.audio) {
                                const audioBytes = atob(ttsData.audio);
                                const audioArray = new Uint8Array(audioBytes.length);
                                for (let i = 0; i < audioBytes.length; i++) {
                                    audioArray[i] = audioBytes.charCodeAt(i);
                                }
                                speculativeCache.audioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
                                console.log(`üîä [SPECULATIVE] ${speaker} audio pre-generated!`);
                            }
                        }
                    } catch (audioErr) {
                        console.error('Speculative audio generation failed:', audioErr);
                    }

                    speculativeCache.ready = true;
                    return data.response;
                })
                .catch(err => {
                    console.error('Speculative generation failed:', err);
                    speculativeCache = { speaker: null, text: null, ready: false, promise: null };
                });
        }

        function clearCache() {
            speculativeCache = { speaker: null, text: null, ready: false, promise: null };
        }

        // ========== AI TURN ==========
        async function processAITurn(speaker) {
            const turnStart = Date.now();
            let usedCache = false;
            let aiText, llmTime;

            // Increment turn number for this turn
            globalTurnNumber++;

            // Set active speaker glow
            setActiveSpeaker(speaker);
            updateStatus(`${getDisplayName(speaker)} is speaking...`);

            // Check for pre-generated first turn (from thinking timer)
            let preGeneratedAudio = null;
            if (speaker === 'AI_1' && window.preGeneratedFirstTurn) {
                console.log('üöÄ Using pre-generated opening speech!');
                aiText = window.preGeneratedFirstTurn.response;
                llmTime = window.preGeneratedFirstTurn.latency || '0';
                preGeneratedAudio = window.preGeneratedFirstTurn.audioBlob || null;
                usedCache = true;
                window.preGeneratedFirstTurn = null; // Clear after use
            }
            // Check speculative cache
            else if (speculativeCache.speaker === speaker && speculativeCache.ready) {
                usedCache = true;
                aiText = speculativeCache.text;
                llmTime = speculativeCache.llmTime;
                preGeneratedAudio = speculativeCache.audioBlob || null;
                clearCache();
            } else if (speculativeCache.speaker === speaker && speculativeCache.promise) {
                updateStatus(`${getDisplayName(speaker)} is thinking...`);
                aiText = await speculativeCache.promise;
                llmTime = speculativeCache.llmTime;
                preGeneratedAudio = speculativeCache.audioBlob || null;
                usedCache = true;
                clearCache();
            } else {
                updateStatus(`${getDisplayName(speaker)} is thinking...`);
                const llmStart = Date.now();
                const response = await fetch(`${API_BASE}/v4/ai-response`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        speaker: speaker,
                        memory: conversationMemory,
                        topic: window.currentGDTopic,
                        turnNumber: globalTurnNumber
                    })
                });
                const data = await response.json();
                aiText = data.response;
                llmTime = ((Date.now() - llmStart) / 1000).toFixed(2);
            }

            // Start speculative for next AI while synthesizing
            const eligible = ['AI_1', 'AI_2', 'AI_3', 'AI_4'].filter(ai =>
                ai !== speaker && orchestratorState.turnCount[ai] < orchestratorState.maxTurns[ai]
            );
            if (eligible.length > 0) {
                eligible.sort((a, b) => orchestratorState.turnCount[a] - orchestratorState.turnCount[b]);
                triggerSpeculativeGeneration(eligible[0]);
            }

            // Synthesize and play (or use pre-generated audio)
            updateStatus(`${getDisplayName(speaker)} is speaking...`);

            let actualAudioBlob = null;

            // Check for pre-generated audio (from thinking timer)
            if (preGeneratedAudio) {
                console.log('üöÄ Using pre-generated audio!');
                actualAudioBlob = preGeneratedAudio;
            } else {
                // Synthesize audio
                const ttsRes = await fetch(`${API_BASE}/synthesize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: aiText, speaker: speaker })
                });

                if (!ttsRes.ok) {
                    console.error('TTS synthesis failed:', ttsRes.status);
                    updateStatus(`${getDisplayName(speaker)} failed to speak`);
                    return;
                }

                const audioBlob = await ttsRes.blob();
                console.log('Audio blob type:', audioBlob.type, 'size:', audioBlob.size);

                // Server returns JSON with base64 audio - need to parse it
                const ttsData = JSON.parse(await audioBlob.text());

                if (!ttsData.audio) {
                    console.error('No audio in TTS response');
                    updateStatus(`${getDisplayName(speaker)} failed to speak`);
                    return;
                }

                // Convert base64 to audio blob
                const audioBytes = atob(ttsData.audio);
                const audioArray = new Uint8Array(audioBytes.length);
                for (let i = 0; i < audioBytes.length; i++) {
                    audioArray[i] = audioBytes.charCodeAt(i);
                }
                actualAudioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
            }

            const audioUrl = URL.createObjectURL(actualAudioBlob);

            console.log(`Audio ready for ${speaker}, size: ${actualAudioBlob.size} bytes`);

            // Track actual speech duration
            let actualSpeechDuration = 0;

            await new Promise((resolve, reject) => {
                currentAudio = new Audio(audioUrl);
                currentAudio.onended = () => {
                    actualSpeechDuration = currentAudio.currentTime || 0;
                    resolve();
                };
                currentAudio.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    resolve(); // Continue even if audio fails
                };
                currentAudio.play().catch(err => {
                    console.error('Audio play() failed:', err);
                    resolve();
                });
            });

            // Log AI speech to session with actual speech duration
            fetch(`${API_BASE}/v4/log-speech`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    speaker: speaker,
                    text: aiText,
                    turnNumber: globalTurnNumber,
                    duration: actualSpeechDuration.toFixed(1)
                })
            });

            // Update state
            orchestratorState.turnCount[speaker]++;
            orchestratorState.lastSpeaker = speaker;
            conversationMemory.push({ speaker: speaker, text: aiText });

            // Clear glow
            setActiveSpeaker(null);

            // Open user speaking window
            openUserSpeakingWindow();
        }

        // ========== USER SPEAKING WINDOW ==========
        function openUserSpeakingWindow() {
            const userEligible = orchestratorState.turnCount.User < orchestratorState.maxTurns.User &&
                (!orchestratorState.userCooldownUntil || Date.now() >= orchestratorState.userCooldownUntil);

            if (!userEligible) {
                setTimeout(() => processNextTurn(), 1000);
                return;
            }

            userWindowOpen = true;
            userStartedSpeaking = false;
            windowCountdown = 4;

            // Show modal
            userModal.classList.add('active');
            modalCountdown.textContent = windowCountdown;
            updateStatus('Your turn', true);

            // Countdown
            windowCountdownInterval = setInterval(() => {
                windowCountdown--;
                modalCountdown.textContent = windowCountdown;
                if (windowCountdown <= 0) {
                    closeUserSpeakingWindow(false);
                }
            }, 1000);

            // Backup timer
            userWindowTimer = setTimeout(() => {
                closeUserSpeakingWindow(false);
            }, 4500);
        }

        function closeUserSpeakingWindow(userClaimed) {
            userWindowOpen = false;

            if (userWindowTimer) {
                clearTimeout(userWindowTimer);
                userWindowTimer = null;
            }
            if (windowCountdownInterval) {
                clearInterval(windowCountdownInterval);
                windowCountdownInterval = null;
            }

            userModal.classList.remove('active');

            if (!userClaimed) {
                processNextTurn();
            }
        }

        // ========== USER RECORDING ==========
        async function startUserRecording() {
            currentTranscript = '';

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                websocket = new WebSocket(WS_BASE);

                return new Promise((resolve) => {
                    websocket.onopen = () => {
                        websocket.send(JSON.stringify({ type: 'start' }));

                        // Trigger speculative generation
                        const nextAI = getNextAISpeakerAfterUser();
                        if (nextAI) {
                            triggerSpeculativeGeneration(nextAI);
                        }

                        const source = audioContext.createMediaStreamSource(mediaStream);
                        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                        audioProcessor.onaudioprocess = (e) => {
                            if (!isRecording || websocket.readyState !== WebSocket.OPEN) return;
                            const input = e.inputBuffer.getChannelData(0);
                            const downsampled = downsample(input, audioContext.sampleRate, 16000);
                            const int16 = floatTo16BitPCM(downsampled);
                            websocket.send(int16.buffer);
                        };

                        source.connect(audioProcessor);
                        audioProcessor.connect(audioContext.destination);
                        isRecording = true;
                        resolve(true);
                    };

                    websocket.onmessage = (e) => {
                        const data = JSON.parse(e.data);
                        if (data.transcript) {
                            currentTranscript = data.transcript;
                        }
                    };

                    websocket.onerror = () => resolve(false);
                });
            } catch (err) {
                console.error('Recording error:', err);
                return false;
            }
        }

        async function stopUserRecording() {
            isRecording = false;

            if (audioProcessor) {
                audioProcessor.disconnect();
                audioProcessor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(t => t.stop());
                mediaStream = null;
            }
            if (websocket) {
                websocket.send(JSON.stringify({ type: 'stop' }));
                websocket.close();
                websocket = null;
            }

            await new Promise(r => setTimeout(r, 500));
            return currentTranscript;
        }

        function downsample(buffer, fromRate, toRate) {
            if (fromRate === toRate) return buffer;
            const ratio = fromRate / toRate;
            const newLength = Math.round(buffer.length / ratio);
            const result = new Float32Array(newLength);
            for (let i = 0; i < newLength; i++) {
                result[i] = buffer[Math.round(i * ratio)];
            }
            return result;
        }

        function floatTo16BitPCM(float32Array) {
            const int16 = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return int16;
        }

        // ========== TURN PROCESSING ==========
        function processNextTurn() {
            const nextSpeaker = getNextSpeaker();

            if (!nextSpeaker) {
                updateStatus('Discussion ended');
                isSessionActive = false;

                // Freeze the GD timer
                if (gdTimerInterval) {
                    clearInterval(gdTimerInterval);
                    gdTimerInterval = null;
                }

                // Log session summary
                const elapsed = gdStartTime ? Math.floor((Date.now() - gdStartTime) / 1000) : 0;
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                const durationStr = `${mins}m ${secs}s`;

                const userTurns = orchestratorState.turnCount.User;
                const aiTurns = Object.entries(orchestratorState.turnCount)
                    .filter(([k]) => k !== 'User')
                    .reduce((sum, [, v]) => sum + v, 0);

                fetch(`${API_BASE}/v4/end-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        totalDuration: durationStr,
                        totalTurns: globalTurnNumber,
                        userTurns: userTurns,
                        participants: `1 Human + 4 AI (Total turns: AI=${aiTurns}, User=${userTurns})`
                    })
                });

                // Trigger Post-GD Analytics
                triggerAnalytics(durationStr);

                return;
            }

            if (nextSpeaker === 'User') {
                openUserSpeakingWindow();
            } else {
                processAITurn(nextSpeaker);
            }
        }

        // ========== EVENT HANDLERS ==========
        startBtn.addEventListener('click', async () => {
            // Get the final topic
            let gdTopic = currentTopic;

            // If no custom topic, generate from genre
            if (!gdTopic && selectedGenre) {
                // Show loading state
                startBtn.disabled = true;
                startBtn.textContent = '‚è≥ Generating...';
                validationHint.textContent = 'üéØ Generating topic from genre, just a sec...';
                validationHint.classList.remove('valid', 'error');
                validationHint.classList.add('valid');

                try {
                    const res = await fetch(`${API_BASE}/v4/generate-topic`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ genre: selectedGenre })
                    });
                    const data = await res.json();
                    gdTopic = data.topic;
                } catch (err) {
                    console.error('Topic generation failed:', err);
                    gdTopic = 'The future of education in the age of AI';
                }
            }

            // Update user's display name
            participantNames['User'] = currentUserName;

            // Store current topic for AI prompts
            window.currentGDTopic = gdTopic;

            // Write session header FIRST (so intro speech is logged after it)
            await fetch(`${API_BASE}/v4/start-session`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ topic: gdTopic, userName: currentUserName })
            });

            // Pre-generate first speaker's response AND audio while user thinks
            console.log('‚ö° Pre-generating Parth\'s opening speech...');
            window.preGeneratedFirstTurn = null;
            fetch(`${API_BASE}/v4/ai-response`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    speaker: 'AI_1',
                    memory: [],
                    topic: gdTopic,
                    turnNumber: 1
                })
            })
                .then(res => res.json())
                .then(async data => {
                    console.log('‚úÖ Parth\'s text pre-generated, now synthesizing audio...');
                    window.preGeneratedFirstTurn = data;

                    // Also pre-generate the audio
                    try {
                        const ttsRes = await fetch(`${API_BASE}/synthesize`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text: data.response, speaker: 'AI_1' })
                        });

                        if (ttsRes.ok) {
                            const ttsData = await ttsRes.json();
                            if (ttsData.audio) {
                                // Convert base64 to audio blob and cache it
                                const audioBytes = atob(ttsData.audio);
                                const audioArray = new Uint8Array(audioBytes.length);
                                for (let i = 0; i < audioBytes.length; i++) {
                                    audioArray[i] = audioBytes.charCodeAt(i);
                                }
                                window.preGeneratedFirstTurn.audioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
                                console.log('‚úÖ Parth\'s audio pre-generated and cached!');
                            }
                        }
                    } catch (audioErr) {
                        console.error('Audio pre-generation failed (will generate on play):', audioErr);
                    }
                })
                .catch(err => {
                    console.error('Pre-generation failed:', err);
                    window.preGeneratedFirstTurn = null;
                });

            // Hide start overlay, show thinking timer
            startOverlay.classList.add('hidden');
            thinkingTopic.textContent = `"${gdTopic}"`;
            thinkingOverlay.classList.remove('hidden');

            // Reset skip button
            skipTimerBtn.disabled = true;
            skipTimerBtn.classList.remove('enabled');
            skipHint.textContent = 'Available in 30 seconds...';

            // Start 60-second countdown
            let timeLeft = 60;
            let skipEnabled = false;
            thinkingTimer.textContent = timeLeft;

            thinkingInterval = setInterval(() => {
                timeLeft--;
                thinkingTimer.textContent = timeLeft;

                // Enable skip after 20 seconds (when 40 seconds left)
                if (timeLeft <= 30 && !skipEnabled) {
                    skipEnabled = true;
                    skipTimerBtn.disabled = false;
                    skipTimerBtn.classList.add('enabled');
                    skipHint.textContent = 'Click to start discussion now';
                }

                // Timer complete
                if (timeLeft <= 0) {
                    clearInterval(thinkingInterval);
                    thinkingInterval = null;
                    startGDSession(gdTopic, currentUserName);
                }
            }, 1000);
        });

        // Skip timer button handler
        skipTimerBtn.addEventListener('click', () => {
            if (skipTimerBtn.disabled) return;

            // Clear the countdown
            if (thinkingInterval) {
                clearInterval(thinkingInterval);
                thinkingInterval = null;
            }

            // Start GD immediately
            startGDSession(window.currentGDTopic, currentUserName);
        });

        // Function to start the actual GD session
        async function startGDSession(gdTopic, userName) {
            // Hide thinking overlay
            thinkingOverlay.classList.add('hidden');

            isSessionActive = true;
            conversationMemory = [];
            globalTurnNumber = 0; // Reset turn counter

            // Reset orchestrator
            orchestratorState.lastSpeaker = null;
            orchestratorState.turnCount = { AI_1: 0, AI_2: 0, AI_3: 0, AI_4: 0, User: 0 };
            orchestratorState.userCooldownUntil = null;

            // Start GD Session Timer
            gdStartTime = Date.now();
            gdTimer.classList.add('active');
            gdTimerValue.textContent = '00:00';

            // Clear any existing interval
            if (gdTimerInterval) clearInterval(gdTimerInterval);

            gdTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gdStartTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                gdTimerValue.textContent = `${mins}:${secs}`;
            }, 1000);

            // Start first turn (session header already written before pre-generation)
            const firstSpeaker = 'AI_1';
            processAITurn(firstSpeaker);
        }

        speakBtn.addEventListener('click', async () => {
            if (!userWindowOpen) return;

            userStartedSpeaking = true;
            closeUserSpeakingWindow(true);

            recordingIndicator.classList.add('active');
            updateStatus('Recording...');

            window.userSpeechStart = Date.now(); // Track speech start time

            const success = await startUserRecording();
            if (!success) {
                recordingIndicator.classList.remove('active');
                updateStatus('Failed to start recording');
                return;
            }
        });

        skipBtn.addEventListener('click', () => {
            if (!userWindowOpen) return;
            closeUserSpeakingWindow(false);
        });

        // Stop recording button handler
        stopRecordingBtn.addEventListener('click', async () => {
            if (!isRecording) return;

            recordingIndicator.classList.remove('active');
            updateStatus('Processing...');

            const transcript = await stopUserRecording();

            if (transcript && transcript.trim()) {
                globalTurnNumber++; // Increment turn number
                orchestratorState.turnCount.User++;
                orchestratorState.lastSpeaker = 'User';
                conversationMemory.push({ speaker: 'User', text: transcript });
                // Log user speech to session with turn metadata
                fetch(`${API_BASE}/v4/log-speech`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        speaker: 'User',
                        text: transcript,
                        turnNumber: globalTurnNumber,
                        duration: Math.round((Date.now() - userSpeechStart) / 1000)
                    })
                });

                startUserCooldown();
                processNextTurn();
            } else {
                updateStatus('No speech detected');
                setTimeout(() => processNextTurn(), 1000);
            }
        });

        // Spacebar handler
        document.addEventListener('keydown', async (e) => {
            if (e.code === 'Space') {
                e.preventDefault();

                if (userWindowOpen && !userStartedSpeaking) {
                    speakBtn.click();
                } else if (isRecording) {
                    // Stop recording
                    recordingIndicator.classList.remove('active');
                    updateStatus('Processing...');

                    const transcript = await stopUserRecording();

                    if (transcript && transcript.trim()) {
                        globalTurnNumber++; // Increment turn number
                        orchestratorState.turnCount.User++;
                        orchestratorState.lastSpeaker = 'User';
                        conversationMemory.push({ speaker: 'User', text: transcript });

                        // Log user speech to session with turn metadata
                        fetch(`${API_BASE}/v4/log-speech`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                speaker: 'User',
                                text: transcript,
                                turnNumber: globalTurnNumber,
                                duration: Math.round((Date.now() - window.userSpeechStart) / 1000)
                            })
                        });

                        startUserCooldown();
                        processNextTurn();
                    } else {
                        updateStatus('No speech detected');
                        setTimeout(() => processNextTurn(), 1000);
                    }
                }
            }
        });

        console.log('V7 - Immersive GD ready!');

        // ========== POST-GD ANALYTICS ==========
        const analyticsOverlay = document.getElementById('analyticsOverlay');
        const analyticsContent = document.getElementById('analyticsContent');
        const analyticsLoading = document.getElementById('analyticsLoading');

        async function triggerAnalytics(durationStr) {
            // Show analytics overlay with loading state
            analyticsOverlay.classList.add('active');
            analyticsLoading.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/v4/analyze-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        transcript: conversationMemory,
                        topic: window.currentGDTopic,
                        userName: currentUserName,
                        totalDuration: durationStr,
                        participantCount: 5,
                        turnCounts: orchestratorState.turnCount
                    })
                });

                const data = await response.json();

                if (data.success && data.analysis) {
                    renderAnalytics(data.analysis, data.sessionOverview);
                } else {
                    analyticsLoading.innerHTML = `
                        <div style="color: #e74c3c; font-size: 16px;">
                            Unable to generate analysis. Please try again.
                        </div>
                        <button class="analytics-btn analytics-btn-primary" onclick="startNewGD()" style="margin-top: 20px;">
                            Start New GD
                        </button>
                    `;
                }
            } catch (error) {
                console.error('Analytics error:', error);
                analyticsLoading.innerHTML = `
                    <div style="color: #e74c3c; font-size: 16px;">
                        Error loading analysis. Please try again.
                    </div>
                    <button class="analytics-btn analytics-btn-primary" onclick="startNewGD()" style="margin-top: 20px;">
                        Start New GD
                    </button>
                `;
            }
        }

        function renderAnalytics(analysis, overview) {
            const names = { 'AI_1': 'Parth', 'AI_2': 'Sneha', 'AI_3': 'Harsh', 'AI_4': 'Anshika', 'User': currentUserName || 'You' };

            analyticsContent.innerHTML = `
                <div class="analytics-header">
                    <div class="analytics-title">üìä Your GD Performance Report</div>
                    <div class="analytics-subtitle">Personalized feedback on your discussion</div>
                </div>

                <!-- Section 1: Session Overview -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Session Overview</div>
                    <div class="session-stats">
                        <div class="stat-item">
                            <div class="stat-value">${overview.duration || 'N/A'}</div>
                            <div class="stat-label">Duration</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${overview.participantCount || 5}</div>
                            <div class="stat-label">Participants</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${overview.userTurnCount || 0}</div>
                            <div class="stat-label">Your Turns</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${globalTurnNumber}</div>
                            <div class="stat-label">Total Turns</div>
                        </div>
                    </div>
                    <p style="margin-top: 16px; color: #a29bfe; font-size: 13px;">
                        <strong>Topic:</strong> ${overview.topic || window.currentGDTopic}
                    </p>
                </div>

                <!-- Section 2: GD Summary -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Discussion Summary</div>
                    <div class="analytics-section-content">
                        <p>${analysis.gdSummary || 'Summary not available.'}</p>
                    </div>
                </div>

                <!-- Section 3: Key Themes -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Key Themes Discussed</div>
                    <div class="theme-tags">
                        ${(analysis.keyThemes || []).map(theme => `
                            <div class="theme-tag">${theme}</div>
                        `).join('')}
                    </div>
                </div>

                <!-- Section 4: Your Contributions -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Your Contributions</div>
                    <div class="analytics-section-content">
                        ${(analysis.userContributions && analysis.userContributions.length > 0) ?
                    analysis.userContributions.map(contrib => `
                                <div class="contribution-item">
                                    <div class="contribution-turn">Turn ${contrib.turn}</div>
                                    <div class="contribution-text">${contrib.summary}</div>
                                </div>
                            `).join('') :
                    '<p style="color: #a29bfe;">No speaking contributions recorded. Consider speaking more in future discussions!</p>'
                }
                    </div>
                </div>

                <!-- Section 5: Personalized Feedback -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Personalized Feedback</div>
                    <div class="analytics-section-content">
                        <div class="feedback-category">
                            <div class="feedback-category-title strengths">‚úì What You Did Well</div>
                            <div class="feedback-points">
                                ${(analysis.feedback?.strengths || ['Good participation']).map(s => `
                                    <div class="feedback-point">‚Ä¢ ${s}</div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="feedback-category">
                            <div class="feedback-category-title improvements">‚Üë Areas for Improvement</div>
                            <div class="feedback-points">
                                ${(analysis.feedback?.improvements || ['Continue practicing']).map(i => `
                                    <div class="feedback-point">‚Ä¢ ${i}</div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Section 6: Missed Angles -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Unexplored Perspectives</div>
                    <div class="analytics-section-content">
                        ${(analysis.missedAngles || []).map(angle => `
                            <p>üí° ${angle}</p>
                        `).join('')}
                    </div>
                </div>

                <!-- Section 7: Flow Assessment -->
                <div class="analytics-section">
                    <div class="analytics-section-title">Overall GD Flow</div>
                    <div class="flow-metrics">
                        <div class="flow-metric">
                            <div class="flow-metric-label">Flow</div>
                            <div class="flow-metric-value">${analysis.flowAssessment?.flow || 'Moderate'}</div>
                        </div>
                        <div class="flow-metric">
                            <div class="flow-metric-label">Balance</div>
                            <div class="flow-metric-value">${analysis.flowAssessment?.balance || 'Varied'}</div>
                        </div>
                        <div class="flow-metric">
                            <div class="flow-metric-label">Engagement</div>
                            <div class="flow-metric-value">${analysis.flowAssessment?.engagement || 'Moderate'}</div>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="analytics-actions">
                    <button class="analytics-btn analytics-btn-secondary" onclick="downloadPDF()">
                        üìÑ Download Report
                    </button>
                    <button class="analytics-btn analytics-btn-primary" onclick="startNewGD()">
                        üîÑ Start New GD
                    </button>
                </div>
            `;
        }

        function startNewGD() {
            // Hide analytics overlay
            analyticsOverlay.classList.remove('active');
            analyticsContent.innerHTML = `
                <div class="analytics-loading" id="analyticsLoading">
                    <div class="analytics-loading-spinner"></div>
                    <div class="analytics-loading-text">Analyzing your discussion...</div>
                </div>
            `;

            // Reset all state
            conversationMemory = [];
            globalTurnNumber = 0;
            orchestratorState.lastSpeaker = null;
            orchestratorState.turnCount = { AI_1: 0, AI_2: 0, AI_3: 0, AI_4: 0, User: 0 };
            orchestratorState.userCooldownUntil = null;
            window.preGeneratedFirstTurn = null;
            window.currentGDTopic = null;

            // Hide GD timer
            gdTimer.classList.remove('active');

            // Show start overlay
            startOverlay.classList.remove('hidden');
            startBtn.disabled = true;
            validationHint.textContent = 'Fill your name and select a topic or genre to start';

            // Reset form
            userNameInput.value = '';
            topicInput.value = '';
            currentTopic = '';
            selectedGenre = null;
            genreCards.forEach(c => c.classList.remove('selected'));
        }

        function downloadPDF() {
            // Simple alert for now - proper PDF generation would require a library
            alert('PDF download feature coming soon! For now, you can use your browser\'s Print function (Ctrl+P / Cmd+P) to save as PDF.');
        }
    </script>
</body>

</html>